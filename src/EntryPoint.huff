// TODO getNonce(address _sender, uint192 _key);
// TODO getUserOpHash(UserOperation calldata _op);
// TODO function handleOps(UserOperation[] calldata ops, address payable beneficiary);

// UserOp
//struct UserOperation {
//    address sender; UOO
//    uint256 nonce; UOO+0x20
//    bytes initCode; UOO+0x40
//    bytes callData; UOO+0x60
//    uint256 callGasLimit; UOO+0x80
//    uint256 verificationGasLimit; UOO+0xa0
//    uint256 preVerificationGas; UOO+0xc0
//    uint256 maxFeePerGas; UOO+0xe0
//    uint256 maxPriorityFeePerGas; UOO+0x100
//    bytes paymasterAndData; UOO+0x120
//    bytes signature; UOO+0x140
//}

// Memory Layout
// [0x00 ~ 0x20) : scratch space
// [0x20 ~ 0x40) : scratch space
// [0x40 ~ 0x60) : memory size
// [0x60 ~ 0x80) : zero slots ( The zero slot is used as initial value for dynamic memory arrays and should never be written to (the free memory pointer points to 0x80 initially). )
// [0x80 ~ 0xa0) : userOpSize
// [0xa0 ~ 0xc0) : currentUserOp
// [0xc0 ~ 0xe0] : currentUserOpLength
// THEN: current UserOp formatted for validateUserOp function call
// [0xe0 ~ 0xe4) : validateUserOpFunctionSig (0x0825d1fc)
// [0xe4 ~ 0x104) : currentUserOpOffset (0x60)
// [0x104 ~ 0x124) : currentUserOpHash
// [0x124 ~ 0x144) : missingAccountFunds
// [0x144 ~ ...) : currentUserOp

#define constant UMO_SIZE = 0x1c0

#define constant USEROPHASH_LOCATION = 0x140

#define macro KECCAK_DYNAMIC() = takes(3) returns(2){
  // [OFFSET, UMO, UOO]
    number pop
    dup2 0x140 add            // [UMO + 140, OFFSET, UMO, UOO]
    dup4                      // [UOO, UMO + 140, OFFSET, UMO, UOO]
    dup3 add calldataload     // [initcode_Offset, UMO+140, OFFSET, UMO, UOO]
    dup5 add                  // [UOO + inticode_Offset, UMO + 140, OFFSET, UMO, UOO]
    dup1                      // [UOO + initcode_Offset, ", UMO + 140, OFFSET, UMO, UOO]
    calldataload              // [initcode_length, UOO + initcode_offset, UMO+140, OFFSET, UMO, UOO]
    dup1                      // [initcode_length, ", UOO + initcode_offset, UMO + 140, OFFSET, UMO, UOO]
    swap2                     // [UOO + initcode_offset, initcode_length, ", UMO + 140, OFFSET, UMO, UOO]
    0x20 add                  // [UOO + initcode_offset + 0x20, initcode_length, ", UMO + 140, OFFSET, UMO, UOO]
    dup4                      // [UMO + 0x140, UOO + initcode_offset + 0x20, initcode_length, ", UMO + 140, OFFSET, UMO, UOO]
    calldatacopy              // [initcode_length, UMO + 140, OFFSET, UMO, UOO]
    swap1                     // [UMO + 140, initcode_length, OFFSET, UMO, UOO]
    sha3                      // [initcode_hash, OFFSET, UMO, UOO]
    swap1                     // [OFFSET, initcode_hash, UMO, UOO]
    dup3 add                  // [OFFSET + UMO, initcode_hash, UMO, UOO]
    mstore
  // [UMO, UOO]
}

#define macro KECCAK_USEROP() = takes(1) returns(1) {
  // [UMO]
  0x140 dup2                      // [UMO, 0x140, UMO]
  sha3                            // [userOpHash, UMO]
  address                         // [address, userOpHash, UMO]
  chainid                         // [chainid, address, userOpHash, UMO]
  0x180 dup5 add mstore           // [address, userOpHash, UMO]
  0x160 dup4 add mstore           // [userOpHash, UMO]
  0x140 dup3 add mstore           // [UMO]
  0x60 dup2 0x140 add sha3        // [finalUserOpHash, UMO]
  0x140 dup3 add mstore           // [UMO]
  // [UMO]
}

// #define macro COPY_USEROP() = takes(1) returns(2){ // returns UMO
//     // [UserOp_Offset]
//     [UMO_SIZE]
//     0xa0 mload                // [currentUserOp, 0x1a0, UOO]
//     mul                       // [currentUserOp * 0x1a0, UOO]
//     0xc0 add                  // [0xc0 + currentUserOp * 0x1a0, UOO] 
//     0x120 dup3                // [UOO, 0x120, UMO, UOO]
//     dup3                      // [UMO, UOO, 0x120, UMO, UOO]
//     calldatacopy              // [UMO, UOO]
//     // keccak initCode
//     // calldatacopy the initCode to UMO + 0x120
//     0x40
//     KECCAK_DYNAMIC()
//     0x60
//     KECCAK_DYNAMIC()
//     0x120
//     KECCAK_DYNAMIC()
//     KECCAK_USEROP()           // [UMO, UOO]
//     dup2                      // [UOO, UMO, UOO]
//     0x120 add                 // [UOO + 0x120, UMO, UOO]
//     calldataload              // [pmOffset_rel, UMO, UOO]
//     dup3 add                  // [pmOffset, UMO, UOO]
//     dup1
//     calldataload              // [paymasterLength, pmOffset, UMO, UOO]
//     iszero end_copy jumpi
//     dup1
//     0x20 add                  // [pmOffset + 0x20, pmOffset, UMO, UOO]
//     calldataload              // [pm1Word, pmOffset, UMO, UOO]
//     0x60 shr                  // [pmAddr, pmOffset, UMO, UOO]
//     dup3 0x120 add mstore      // [pmOffset, UMO, UOO]e
// end_copy:
//     pop                       // [UMO, UOO]
// }

#define macro COPY_USEROP() = takes(1) returns(2){
    // [UserOp_Offset]
    0xa0 mload // [currentOpIndex, UserOp_Offset]]                    
    0x64 add dup1 calldataload // [userOp_i_offset, currentOpIndex, UserOp_Offset]
    swap1 0x20 add calldataload sub // [userOp_i_length, UserOp_Offset]
    dup1 0xc0 mstore // [userOp_i_length, UserOp_Offset]
    __RIGHTPAD(0x0825d1fc) 0xe0 mstore // [userOp_i_length, UserOp_Offset]
    0x60 0xe4 mstore // [userOp_i_length, UserOp_Offset]
    // NOTE: HASH IS STORED BY CALL_VALIDATE_ON_ACCOUNT
    // NOTE: MISSING ACCOUNT FUNDS IS STORED BY CALL_VALIDATE_ON_ACCOUNT
    dup2 0x144 // [memoryOffset, calldataOffset (UserOp_Offset), userOp_i_length, UserOp_Offset]
    calldatacopy // [UserOp_Offset]
    // 0xc0 mload 0x84 add 0xc0 return // example: return [0xc0 - end of UO]
}

#define macro VALIDATE_PREPAYMENT() = takes(2) returns(2) {
    // [userOp_i_offset]
}

#define macro CREATE_ACCOUNT() = takes(2) returns(2) {
  // [userOp_i_offset]
  // @TODO: route account creation through senderCreator contract
  0x144 mload dup1 // [target, target, userOp_i_offset]
  extcodesize // [extcodesize, target, userOp_i_offset]
  iszero not accountDeployed jumpi // [target, userOp_i_offset]
  0x184 mload 0x144 add dup1 mload dup1 // [initCodeLength, initCodeLengthSlot, target, userOp_i_offset]
  iszero invalidUserOp jumpi // [initCodeLength, initCodeLengthSlot, target, userOp_i_offset]
  0x14 swap1 sub // [initCodeLength, initCodeLengthSlot, target, userOp_i_offset]

  0x00 // [retOffset, initCodeLength, initCodeLengthSlot, target, userOp_i_offset]
  swap1 // [initCodeLength, retOffset, initCodeLengthSlot, target, userOp_i_offset]
  0x20 // [retSize, initCodeLength, retOffset, initCodeLengthSlot, target, userOp_i_offset]
  swap3 // [initCodeLengthSlot, initCodeLength, retOffset, retSize, target, userOp_i_offset]
  dup1 0x34 add swap1 // [initCodeLengthSlot, initCodeStart, retOffset, retSize, target, userOp_i_offset]
  0x00 swap1 // [initCodeLengthSlot, value, initCodeStart, retOffset, retSize, target, userOp_i_offset]
  mload 0x60 shl // [target, value, initCodeStart, retOffset, retSize, target, userOp_i_offset]
  gas // [gas, target, value, initCodeStart, retOffset, retSize, target, userOp_i_offset]
  call // [success, target, userOp_i_offset]
  iszero invalidUserOp jumpi // [target, userOp_i_offset]
  0x00 mload eq invalidUserOp jumpi // [userOp_i_offset]

  accountDeployed:
}

#define macro CALL_VALIDATE_ON_ACCOUNT() = takes(2) returns(2) {
  // [userOp_i_offset] 
  // @TODO: CREATE USER OP HASH
  // @TODO: MISSING ACCOUNT FUNDS
  0x00 // [retSize, userOp_i_offset]
  0x00 // [retOffset, retSize, userOp_i_offset]
  0xc0 mload 0x64 add // [UO_length, retOffset, retSize, userOp_i_offset]
  0xe0 // [argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0x00 // [value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0x144 mload // [target, value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0xe4 mload // [gas, target, value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  call // [success, userOp_i_offset]
  iszero invalidUserOp jumpi // [userOp_i_offset]
}

#define macro CALL_EXECUTE_ON_ACCOUNT() = takes(2) returns(2) {
  // [userOp_i_offset] 
  0x00 // [retSize, userOp_i_offset]
  0x00 // [retOffset, retSize, userOp_i_offset]
  0x1a4 mload 0x144 add dup1 mload // [UO_length, calldataOffset, retOffset, retSize, userOp_i_offset]
  swap1 0x20 add // [argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0x00 // [value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0x144 mload // [target, value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  0xc4 mload // [gas, target, value, argOffset, argSize, retOffset, retSize, userOp_i_offset]
  call // [success, userOp_i_offset]
  iszero invalidUserOp jumpi // [userOp_i_offset]
}

#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xE0 shr
    0x1fad948c eq handle_ops jumpi  // jump to handleOps
    
    handle_ops:
      0x44                          // [userOps_offset]
      dup1                          // [userOps_offset, userOps_offset]
      calldataload                  // [userOps_length, userOps_offset]
      0x80 mstore                   // [userOps_offset]
      0x20 add                      // [userOps_offset]
      dup1                          // [cursor, userOps_offset]
    loop_verification_phase:
      dup1                          // [cursor, cursor, userOps_offset]
      calldataload                  // [userOp_rel_offset, cursor, userOps_offset]
      dup3 add                      // [userOp_i_offset, cursor, userOps_offset]
      0x80 mload                    // [opSize, userOp_i_offset]
      // @TODO: keep 0xa0 mload on stack to use below
      0xa0 mload                    // [current_i, opSize, userOp_i_offset]
      eq execution_phase jumpi      // [userOp_i_offset]
      COPY_USEROP()                 // [userOp_i_offset]
      CREATE_ACCOUNT()              // [userOp_i_offset]
      CALL_VALIDATE_ON_ACCOUNT()    // [userOp_i_offset]
      VALIDATE_PREPAYMENT()         // [userOp_i_offset]
      0xa0 mload                    // [cursor, userOp_i_offset]                    
      0x01 add 0xa0 mstore          // [newCursor, userOps_offset]
      0x20 add
      loop_verification_phase jump
    execution_phase:
      0x00 0xa0 mstore
      pop
      0xa4
      execution_phase_internal:
        0x80 mload                    // [opSize, userOp_i_offset]
        0xa0 mload                    // [current_i, opSize, userOp_i_offset]
        eq finish jumpi               // [userOp_i_offset]
        COPY_USEROP()                 // [userOp_i_offset]
        CALL_EXECUTE_ON_ACCOUNT()     // [userOp_i_offset]
        0xa0 mload                    // [cursor, userOp_i_offset]                    
        0x01 add 0xa0 mstore          // [newCursor, userOps_offset]
        0x20 add                      // [userOp_i_offset]
        execution_phase_internal jump
    finish:
      stop
    invalidUserOp:
      0x00 0x00 revert
}
